##########################################################
# Demo code for POSH Integartion Meeting
# Created by Brown University Group
# Founded by DARPA
##########################################################

import math
import re
import sys

# Welcome code
welcome_text = 'Welcome to use VT Sensor Compiler\n\nMade by Brown University Team\n'
sensor_size_x = 100.00
sensor_size_y = 50.00
print('\033c')
print('\n')
print(welcome_text) # if the input argument number is correct, then print out welcome text and continue

##########################################################
## Read input arguments
##########################################################

# count the arguments
argument_num = len(sys.argv) - 1

# Check if numebrs are right
if argument_num <= 0:
    print("no coordinate input recognized, number of sensor will be set to default of 1, coordinate will be set to default of '0.000 0.000'")
    print('\n\n\n')
    no_input = 1
    num_of_sensor = 1
    coordinate_x_temp = 0
    coordinate_y_temp = 0
else:
    no_input = 0
    if (argument_num % 2) == 0:
        print("Sensor tile size: {0} X {1} (um*um)".format(sensor_size_x,sensor_size_y))
        print('\n\n')
        num_of_sensor = argument_num/2
    else:
        print("Please enter even number of coordinates")
        exit(1)

##########################################################
## Define Coordinates of the sensor
##########################################################

coordinate_x = []
coordinate_y = []
position = 1

if no_input == 0:   # check if there is no input
    while ( num_of_sensor >= position):
        coordinate_x_temp = float(sys.argv[2*position-1])
        coordinate_y_temp = float(sys.argv[2*position])
        coordinate_x.append(coordinate_x_temp)
        coordinate_y.append(coordinate_y_temp)
        position = position + 1
else:
    coordinate_x.append(coordinate_x_temp)
    coordinate_y.append(coordinate_y_temp)

print("Total of {0:d} sensor tiles requested\n".format(num_of_sensor))

print("Location of each sensor tile (unit in um):\n")
for i in range(0,num_of_sensor):
    print("Sensor tile #{2:d}: x - {0:.3f}   y - {1:.3f} \n".format(coordinate_x[i],coordinate_y[i],(i+1)))
    
print("\nSPI will be daisy-chained between each sensor tile\n\n\n")

##########################################################
## Read LEF file
##########################################################

print("Reading LEF file...\n")

# open LEF file
file = open('./Brown_PVTSensor.lef', 'r')
lines = file.readlines()
lookup = '  PIN '
linenum = 0

# Initialize groups
pin = []
direction = []
use = []
layer = []
pin_offset_ll_x = [] # x axis of lower left corner
pin_offset_ll_y = [] # y axis of lower left corner
pin_offset_ur_x = [] # x axis of upper right corner
pin_offset_ur_y = [] # y axis of upper right corner

for linenum, line in enumerate(lines, 0):
    if lookup in line:
        pin_temp = re.findall(r"\w+\.?\w*",lines[linenum])
        pin.append(pin_temp[1])
        direction_temp = re.findall(r"\w+\.?\w*",lines[linenum+1])
        direction.append(direction_temp[1])
        use_temp = re.findall(r"\w+\.?\w*",lines[linenum+2])
        use.append(use_temp[1])
        layer_temp = re.findall(r"\w+\.?\w*",lines[linenum+4])
        layer.append(layer_temp[1])
        offset_temp = re.findall(r"\w+\.?\w*",lines[linenum+5])
        pin_offset_ll_x.append(float(offset_temp[1]))
        pin_offset_ll_y.append(float(offset_temp[2]))
        pin_offset_ur_x.append(float(offset_temp[3]))
        pin_offset_ur_y.append(float(offset_temp[4]))

##########################################################
## Determine PIN parameters
##########################################################

#### Just to clarify at first: all pins have origin of N(North, Rotate for 0 degree), the offset point will be at the lower left of the pin. The style of the pins will be ( 0 0 ) ( 2000*W 2000*H ) ( lowerLeft_offset_x*2000 lowerLeft_offset_y*2000 )
#### However, the style of the DEF file generated by Innovus is ( -1000*W 0 ) ( 1000*W 2000*H ) ( lowerCenter_offset_x*2000 lower_Center_offset_y*2000).
#### Presumably, they should be the same, but just to unite the style of DEF file, the following numbering scheme will be the same as auto-generated by Innovus

pin_offset_lc_x = []  # calculate the coordinate of lower center of the pins
pin_offset_lc_y = []
pin_width = []  # calculate the width of the pins
pin_height = []  # calculate the height of the pins

# calculate offset value of pins in single sensor tile
for i in range(len(pin)):
    pin_offset_lc_x_temp = ( pin_offset_ll_x[i] + pin_offset_ur_x[i] ) / 2
    pin_offset_lc_x.append(pin_offset_lc_x_temp)
    pin_offset_lc_y.append(pin_offset_ll_y[i])
    pin_width.append( pin_offset_ur_x[i] - pin_offset_ll_x[i] )
    pin_height.append( pin_offset_ur_y[i] - pin_offset_ll_y[i] )
    
##########################################################
## Write verilog file
##########################################################

# Create a new Verilog file
f = open("Sensor_Compiler_Output.v","w")

# write timescale and top module statement
f.write("`timescale 10ps / 1ps \n\nmodule sensor_top(\ninput wire i_Clk,\ninput wire A_BGR_PS,\ninput wire i_CntWin,\ninput wire i_Rst_n,\ninput wire i_SPI_CS_n,\ninput wire i_SPI_Clk,\ninput wire i_SPI_MOSI,\noutput wire o_SPI_MISO,\n\ninout wire AVDD,\ninout wire DVDD,\ninout wire GND\n);\n\n")

# declare connection wires between sensors (SPI connection)
f.write("wire ["+str(num_of_sensor-2)+":0] SPI_conn;\n\n")

# insert modules
for x in range(num_of_sensor):
    f.write("Brown_PVTSensor S" + str(x) + "(\n")
    f.write(".i_Clk(i_Clk),\n.A_BGR_PS(A_BGR_PS),\n.i_CntWin(i_CntWin),\n.i_Rst_n(i_Rst_n),\n.i_SPI_CS_n(i_SPI_CS_n),\n.i_SPI_Clk(i_SPI_Clk),\n")
    if x == 0:
        f.write(".i_SPI_MOSI(i_SPI_MOSI),\n\n")
    else:
        f.write(".i_SPI_MOSI(SPI_conn[" + str(x-1) + "]),\n\n")
    if x == (num_of_sensor-1):
        f.write(".o_SPI_MISO(o_SPI_MISO),\n\n")
    else:
        f.write(".o_SPI_MISO(SPI_conn[" + str(x) + "]),\n\n")
    
    f.write(".AVDD(AVDD),\n.DVDD(DVDD),\n.GND(GND)\n);\n\n")
        
# end top module
f.write("endmodule\n\n")

# declare sensor module
f.write("module Brown_PVTSensor(\ninput wire i_Clk,\ninput wire A_BGR_PS,\ninput wire i_CntWin,\ninput wire i_Rst_n,\ninput wire i_SPI_CS_n,\ninput wire i_SPI_Clk,\ninput wire i_SPI_MOSI,\noutput wire o_SPI_MISO,\n\ninout wire AVDD,\ninout wire DVDD,\ninout wire GND\n);\n\nendmodule\n\n")

f.close()

print("Verilog netlist generated...\n")

##########################################################
## Write DEF file
##########################################################

# Create a new DEF file
f = open("Sensor_Compiler_Output.def","w")

# import time
from time import ctime
current_time = ctime()

# Write top info
f.write("###############################################################\n#  Generated by:      Brown University Team - Sensor Compiler\n#  OS:                Linux x86_64(Host ID scale01.engin.brown.edu)\n")
f.write("#  Generated on:      " + current_time + "\n")
f.write("#  Design:            Brown_PVTSensor_Compiler\n")
f.write("###############################################################\n\n")

# Write inital instances
f.write("VERSION 5.8 ;\nDIVIDERCHAR \"/\" ;\nBUSBITCHARS \"[]\" ;\nDESIGN Brown_PVTSensor ;\nUNITS DISTANCE MICRONS 2000 ;\n\n")

# Write components (hard macros)
f.write(" COMPONENTS " + str(num_of_sensor) + " ;\n")
for i in range(num_of_sensor):
    f.write("- Brown_PVTSensor/S" + str(i) + " Brown_PVTSensor + PLACED ( " + str(coordinate_x[i]) + " " + str(coordinate_y[i]) + " ) FS\n ;\n")
f.write("END COMPONENTS\n\n")

# Write pins of the components
# just to clarify before going forward, I am not sure what is the correct syntax to define pin's location for every same hard macro. I use 'S(X)/PIN' here. This is my best guess for now.
f.write("PINS " + str(num_of_sensor*len(pin)) + " ;\n") # number of sensors times number of pins in each sensor
for i in range(num_of_sensor):
    for j in range(len(pin)):
        if (pin[j] == 'i_SPI_MOSI'):
            if i == 0:
                f.write("- S" + str(i) + "/" + pin[j] + "  + NET " + pin[j] + " + DIRECTION " + direction[j] + " + USE " + use[j] + "\n")
            else:
                f.write("- S" + str(i) + "/" + pin[j] + "  + NET SPI_conn[" + str(i) + "] + DIRECTION " + direction[j] + " + USE " + use[j] + "\n")
        elif (pin[j] == 'o_SPI_MISO'):
            if i == (num_of_sensor-1):
                f.write("- S" + str(i) + "/" + pin[j] + "  + NET " + pin[j] + " + DIRECTION " + direction[j] + " + USE " + use[j] + "\n")
            else:
                f.write("- S" + str(i) + "/" + pin[j] + "  + NET SPI_conn[" + str(i) + "] + DIRECTION " + direction[j] + " + USE " + use[j] + "\n")
        else:
            f.write("- S" + str(i) + "/" + pin[j] + "  + NET " + pin[j] + " + DIRECTION " + direction[j] + " + USE " + use[j] + "\n")
        f.write("  + LAYER " + layer[j] + " ( -" + str(pin_width[j]*1000) + " 0 ) ( " + str(pin_width[j]*1000) + " " + str(pin_height[j]*2000) + " )\n")
        f.write("  + PLACED ( " + str((pin_offset_lc_x[j]+coordinate_x[i])*2000) + " " + str((pin_offset_lc_y[j]+coordinate_y[i])*2000) + " ) N ;\n")    # add sensor coordinate to pin locations
f.write("END PINS\n\n")

# Write Nets
# Still, I am not sure what is the correct syntax to define nets between hard macro. This is my best guess for now.

# Write nets connected to pins
f.write("NETS " + str(len(pin)+num_of_sensor-1) + " ;\n")     ## daizy chaining SPI
for j in range(len(pin)):
    f.write("- " + pin[j] + "\n")
    if (pin[j] == 'i_SPI_MOSI'):
        f.write("  ( PIN " + pin[j] + " ) ( S0 " + pin[j] + " )\n")
    elif (pin[j] == 'o_SPI_MISO'):
        f.write("  ( PIN " + pin[j] + " ) ( S" + str(num_of_sensor-1) + " " + pin[j] + " )\n")
    else:
        f.write("  ( PIN " + pin[j] + " ) ")
        for i in range(num_of_sensor):
            f.write("( S" + str(i) + " " + pin[j] + " )")
        f.write("\n")
# Write nets connected between SPI
for i in range(num_of_sensor-1):
    f.write("- SPI_conn[" + str(i) + "]\n")
    f.write("  ( S" + str(i) + " o_SPI_MISO ) ( S" + str(i+1) + " i_SPI_MOSI )\n")
f.write("END NETS\n\n")  

# End design
f.write("END DESIGN\n")

f.close()

print("DEF file generated...\n")

##########################################################
## Complete
##########################################################

print("Complete!\n")

exit()























